import type { EphemeralKeyPair } from './encryption/types.js';
import { BaseName } from 'multibase';
/**
 * @deprecated Signers will be expected to return base64url `string` signatures.
 */
export interface EcdsaSignature {
    r: string;
    s: string;
    recoveryParam?: number;
}
/**
 * @deprecated Signers will be expected to return base64url `string` signatures.
 */
export type ECDSASignature = {
    compact: Uint8Array;
    recovery?: number;
};
export type JsonWebKey = {
    crv: string;
    kty: string;
    x?: string;
    y?: string;
    [key: string]: any;
};
export declare function bytesToBase64url(b: Uint8Array): string;
export declare function base64ToBytes(s: string): Uint8Array;
export declare function bytesToBase64(b: Uint8Array): string;
export declare function base58ToBytes(s: string): Uint8Array;
export declare function bytesToBase58(b: Uint8Array): string;
export declare const supportedCodecs: {
    'ed25519-pub': number;
    'x25519-pub': number;
    'secp256k1-pub': number;
    'bls12_381-g1-pub': number;
    'bls12_381-g2-pub': number;
    'p256-pub': number;
};
/**
 * Encodes the given byte array to a multibase string (defaulting to base58btc).
 * If a codec is provided, the corresponding multicodec prefix will be added.
 *
 * @param b - the Uint8Array to be encoded
 * @param base - the base to use for encoding (defaults to base58btc)
 * @param codec - the codec to use for encoding (defaults to no codec)
 *
 * @returns the multibase encoded string
 *
 * @public
 */
export declare function bytesToMultibase(b: Uint8Array, base?: BaseName, codec?: keyof typeof supportedCodecs | number): string;
/**
 * Converts a multibase string to the Uint8Array it represents.
 * This method will assume the byte array that is multibase encoded is a multicodec and will attempt to decode it.
 *
 * @param s - the string to be converted
 *
 * @throws if the string is not formatted correctly.
 *
 * @public
 */
export declare function multibaseToBytes(s: string): Uint8Array;
export declare function hexToBytes(s: string, minLength?: number): Uint8Array;
export declare function encodeBase64url(s: string): string;
export declare function decodeBase64url(s: string): string;
export declare function bytesToHex(b: Uint8Array): string;
export declare function bytesToBigInt(b: Uint8Array): bigint;
export declare function bigintToBytes(n: bigint, minLength?: number): Uint8Array;
export declare function stringToBytes(s: string): Uint8Array;
export declare function toJose({ r, s, recoveryParam }: EcdsaSignature, recoverable?: boolean): string;
export declare function fromJose(signature: string): {
    r: string;
    s: string;
    recoveryParam?: number;
};
export declare function toSealed(ciphertext: string, tag?: string): Uint8Array;
export declare function leftpad(data: string, size?: number): string;
/**
 * Generate random x25519 key pair.
 */
export declare function generateKeyPair(): {
    secretKey: Uint8Array;
    publicKey: Uint8Array;
};
/**
 * Generate private-public x25519 key pair from `seed`.
 */
export declare function generateKeyPairFromSeed(seed: Uint8Array): {
    secretKey: Uint8Array;
    publicKey: Uint8Array;
};
export declare function genX25519EphemeralKeyPair(): EphemeralKeyPair;
//# sourceMappingURL=util.d.ts.map